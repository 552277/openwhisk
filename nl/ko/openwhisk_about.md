---

copyright:
  years: 2016, 2018
lastupdated: "2018-01-09"

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# {{site.data.keyword.openwhisk_short}} 정보

{{site.data.keyword.openwhisk}}는 이벤트 또는 직접 호출에 대한 응답으로 코드를 실행하는 서버리스 컴퓨팅 또는 FaaS(Function as a Service)라고도 하는 이벤트 구동 컴퓨팅 플랫폼입니다. 다음 그림은 상위 레벨 {{site.data.keyword.openwhisk}} 아키텍처를 보여줍니다.
{: shortdesc}

![{{site.data.keyword.openwhisk_short}} 아키텍처](./images/OpenWhisk.png)

이벤트의 예에는 데이터베이스 레코드에 대한 변경, 특정 온도를 초과하는 IoT 센서 측정값, GitHub 저장소에 대한 새 코드 커미트 또는 웹이나 모바일 앱의 단순 HTTP 요청 등이 포함됩니다. 외부 또는 내부 이벤트 소스의 이벤트는 트리거를 통해 전달되며, 규칙은 조치가 이러한 이벤트에 반응할 수 있도록 허용합니다. 

조치는 JavaScript 또는 Swift 코드의 소형 스니펫이거나 Docker 컨테이너에 임베드된 사용자 정의 2진 코드일 수 있습니다. {{site.data.keyword.openwhisk_short}}의 조치는 트리거가 실행될 때마다 즉시 배치되고 실행됩니다. 실행되는 트리거가 많을수록 더 많은 조치가 호출됩니다. 트리거가 실행되지 않으면 조치 코드가 실행되지 않으며 비용은 0으로 유지됩니다. 

트리거와 조치의 연관에 추가하여 {{site.data.keyword.openwhisk_short}} API, CLI 또는 iOS SDK를 사용하여 조치를 직접 호출할 수 있습니다. 또한 코드를 작성하지 않고도 조치 세트를 체인으로 연결할 수도 있습니다. 체인의 각 조치는 시퀀스에서 다음에 입력으로 전달되는 조치 하나의 출력으로 순서대로 호출됩니다. 

전통적인 장기 실행 가상 머신 또는 컨테이너에서는 단일 인스턴스의 가동 중단에 대해 복원성을 갖도록 다중 VM 또는 컨테이너를 배치하는 것이 일반적인 관례입니다. 그러나 {{site.data.keyword.openwhisk_short}}에서는 복원성과 관련된 비용 오버헤드가 없는 대체 모델을 제공합니다. 실행 중인 조치의 수가 항상 트리거 속도와 일치하므로, 요청 시에 조치를 실행하면 고유의 확장성과 최적의 이용률이 제공됩니다. 또한 개발자는 이제 코드에만 집중할 수 있으며 기본 서버, 스토리지, 네트워크 및 운영 체제 인프라의 모니터링, 패칭 및 보안에 대해 염려할 필요가 없습니다. 

서비스 및 이벤트 제공자와의 통합이 패키지에서 추가될 수 있습니다. 패키지는 피드 및 조치의 번들입니다. 피드는 트리거 이벤트를 실행하도록 외부 이벤트 소스를 구성하는 코드의 조각입니다. 예를 들어, Cloudant 변경 피드로 작성된 트리거는 문서가 수정되거나 Cloudant 데이터베이스에 추가될 때마다 트리거를 실행하도록 서비스를 구성합니다. 서비스 제공자가 가용성을 제공할 수 있는 재사용 가능한 로직을 패키지의 조치에서 표시하므로, 개발자는 서비스를 이벤트 소스로서 사용하고 해당 서비스의 API를 호출할 수 있습니다. 

패키지의 기존 카탈로그는 유용한 기능으로 애플리케이션을 강화하고 에코시스템의 외부 서비스에 액세스할 수 있는 빠른 방법을 제공합니다. {{site.data.keyword.openwhisk_short}} 사용 외부 서비스의 예에는 Cloudant, The Weather Company, Slack 및 GitHub 등이 포함됩니다. 


## {{site.data.keyword.openwhisk_short}}의 작동 방식
{: #openwhisk_how}

오픈 소스 프로젝트인 OpenWhisk는 Nginx, Kafka, Consul, Docker 및 CouchDB 등을 포함한 거물급 제품들의 어깨 위에 자리하고 있습니다. 이러한 모든 컴포넌트가 “서버리스 이벤트 기반 프로그래밍 서비스”의 구현을 위해 통합됩니다. 모든 컴포넌트를 보다 자세히 설명하기 위해 발생 시에 시스템을 통한 조치의 호출을 추적해 보겠습니다. OpenWhisk에서 호출은 서버리스 엔진이 수행하는 핵심 기능입니다. 즉, 사용자가 시스템에 피드한 코드를 실행하고 해당 실행의 결과를 리턴합니다. 

### 조치 작성

설명에 일부 컨텍스트를 제공하기 위해 우선 시스템에서 조치를 작성할 수 있습니다. 그리고 해당 조치를 사용하여 시스템을 통한 추적 중에 개념을 설명합니다. 다음 명령은 [올바르게 설정된 OpenWhisk CLI](https://github.com/openwhisk/openwhisk/tree/master/docs#setting-up-the-openwhisk-cli)를 가정합니다. 

우선, 표준 출력에 “Hello World”를 출력하고 키 “hello” 아래에 “world”가 포함된 JSON 오브젝트를 리턴하는 다음 코드가 포함된 *action.js* 파일을 작성하십시오. 
```javascript
function main() {
    console.log('Hello World');
    return { hello: 'world' };
}
```
{: codeblock}

다음 명령을 실행하여 조치를 작성하십시오. 
```
wsk action create myAction action.js
```
{: pre}

이제 다음 명령을 실행하여 해당 조치를 호출하십시오. 
```
wsk action invoke myAction --result
```
{: pre}

## 내부 처리 플로우
OpenWhisk의 뒤에서 무슨 일이 발생합니까? 

![OpenWhisk 처리 플로우](images/OpenWhisk_flow_of_processing.png)

### 시스템 진입: nginx

우선 OpenWhisk의 사용자 대면 API는 완벽하게 HTTP 기반이며 RESTful 디자인을 따릅니다. 결과적으로, wsk-CLI를 통해 전송되는 명령은 기본적으로 OpenWhisk 시스템에 대한 HTTP 요청입니다. 특정 명령은 대략 다음으로 변환됩니다. 
```
POST /api/v1/namespaces/$userNamespace/actions/myAction
Host: $openwhiskEndpoint
```
{: screen}

여기서 *$userNamespace* 변수에 유념하십시오. 사용자는 최소한 하나의 네임스페이스에 액세스할 수 있습니다. 단순함을 위해 사용자가 *myAction*이 놓여진 네임스페이스를 소유한다고 가정합니다. 

시스템으로의 첫 시작점은 **nginx**를 통한 “HTTP 및 리버스 프록시 서버”입니다. 이는 SSL 종료 및 다음 컴포넌트로 적절한 HTTP 호출을 전달하는 데 사용됩니다. 

### 시스템 진입: 제어기

Nginx는 OpenWhisk를 통한 경로의 다음 컴포넌트인 **제어기**로 HTTP 요청을 전달합니다. (**Akka** 및 **Spray**를 기반으로 하는) 실제 REST API의 Scala 기반 구현이므로, 이는 사용자가 수행할 수 있는 모든 작업에 대한 인터페이스로서의 역할을 합니다. OpenWhisk의 엔티티에 대한 [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) 요청 및 조치의 호출이 포함됩니다. 

제어기는 우선 사용자가 시도하는 작업을 명료화합니다. 이는 HTTP 요청에서 사용되는 HTTP 메소드를 기반으로 이를 수행합니다. 위의 변환에 따라 사용자는 기존 조치에 대해 POST 요청을 발행하며, 제어기는 이를 **조치의 호출**로 변환합니다. 

제어기의 중심 역할(이에 따라 이름)이 부여된 경우, 다음 단계에서 어느 정도는 이를 모두 포함합니다. 

### 인증 및 권한 부여: CouchDB

이제 제어기는 사용자가 누구인지(*인증*)와 해당 엔티티에서 수행할 작업에 대한 권한이 있는지(*권한*) 여부를 확인합니다. 요청에 포함된 신임 정보에 대한 확인은 **CouchDB** 인스턴스의 이른바 **제목** 데이터베이스에 대해 이루어집니다. 

이 경우에는 사용자가 OpenWhisk의 데이터베이스에 존재하는지와 *myAction* 조치(사용자가 소유하는 네임스페이스의 조치로 가정됨)를 호출할 권한이 있는지가 확인됩니다. 후자는 조치를 호출하는 권한을 효과적으로 사용자에게 제공합니다. 

모든 사항에 이상이 없으므로 다음 처리 단계가 시작됩니다. 

### 조치 가져오기: CouchDB… (다시)

사용자가 허용되고 조치 호출 권한을 보유함을 이제 확인했으므로, 제어기는 CouchDB의 **whisks** 데이터베이스에서 이 조치(이 경우에는 *myAction*)를 로드합니다. 

조치의 레코드에는 실제 호출 요청에 포함된 매개변수, 병합된 조치에 전달할 기본 매개변수 및 실행할 코드가 주로 포함되어 있습니다. 여기에는 실행 시에 부과된 리소스 제한사항(예: 이용 가능한 메모리)도 포함되어 있습니다. 

이 특정한 경우에 조치는 매개변수를 취하지 않습니다(함수의 매개변수 정의가 비어 있는 목록임). 따라서 조치에 대한 특정 매개변수를 포함하여 기본 매개변수가 설정되지 않았다고 가정되며, 이 관점에서 보면 가장 사소한 경우가 됩니다. 

### 조치를 호출하는 주체: Consul

이제 제어기(또는 보다 구체적으로 이의 로드 밸런싱 부분)에는 코드 실행을 위한 모든 게 준비되어 있지만, 제어기는 이를 수행할 수 있는 주체를 알아야 합니다. **Consul**(서비스 검색)을 사용하면 해당 상태를 계속해서 확인하여 시스템에서 사용 가능한 실행기를 모니터할 수 있습니다. 이러한 실행기를 **호출기**라고 합니다. 

제어기는 사용 가능한 호출기를 알 수 있고, 이 중에서 하나를 선택하여 요청된 조치를 호출합니다. 

이 경우에 시스템에서 3개의 호출기(호출기 0 - 2)가 사용 가능하며 제어기가 바로 조치를 호출할 수 있도록 *호출기 2*를 선택했다고 가정합니다. 

### 행 구성: Kafka

이제부터, 주로 두 가지의 잘못된 일이 사용자가 전송한 호출 요청에 발생할 수 있습니다. 

1. 시스템에서 장애가 발생하여 사용자의 호출이 유실됩니다. 
2. 시스템에서 매우 과중한 로드가 발생할 수 있으며, 호출은 우선 다른 호출이 완료될 때까지 대기해야 합니다. 

두 가지 모두에 대한 해결책은 “높은 처리량의 분산된 발행/구독 메시징 시스템”인 **Kafka**입니다. 제어기와 호출기는 오직 Kafka에 의해 버퍼링되고 지속되는 메시지를 통해서만 통신합니다. Kafka는 제어기와 호출기 모두에서 *OutOfMemoryException*의 위험성을 유발하는 메모리의 버퍼링 부담을 해소합니다. 또한 이와 동시에 시스템에서 장애가 발생하는 경우에 메시지가 유실되지 않도록 보장합니다. 

호출된 조치를 가져오기 위해 제어기는 메시지를 Kafka에 공개하며, 여기에는 호출할 조치와 해당 조치에 전달할 매개변수(이 경우에는 없음)가 포함되어 있습니다. 이 메시지는 호출기에 전달되며, 이를 제어기는 Consul에서 가져온 목록에서 선택합니다. 

일단 Kafka가 메시지의 수신을 확인하는 경우, 사용자에 대한 HTTP 요청이 **ActivationId**와 함께 응답됩니다. 사용자는 나중에 이를 사용하여 이 특정 호출의 결과에 액세스할 수 있습니다. 이는 시스템이 조치를 호출하는 요청을 일단 수신하게 되면 HTTP 요청이 종료되는 비동기 호출 모델입니다. 동기 모델(블로킹 호출이라고 함)을 사용할 수 있지만, 여기서 다루지는 않습니다. 

### 코드 호출: 호출기

**호출기**는 OpenWhisk의 핵심 기능입니다. 호출기의 임무는 조치를 호출하는 것입니다. 이는 Scala 언어로도 구현되어 있습니다. 그러나 여기에는 그 이상이 있습니다. 격리되고 안전한 방식으로 조치를 실행하기 위해 이는 **Docker**를 사용합니다. 

Docker를 사용하면 빠르고 격리되고 제어된 방식으로 호출되는 각각의 조치마다 자체 캡슐화된 새 환경(*컨테이너*라고 함)을 설정할 수 있습니다. 각각의 조치 호출마다 Docker 컨테이너가 생성되며 조치 코드가 삽입됩니다. 그리고 이 코드는 전달 받은 매개변수를 사용하여 실행되고 해당 결과의 가져오기가 실행된 후에 컨테이너는 영구적으로 삭제됩니다. 오버헤드를 줄이고 응답 시간을 낮출 수 있도록 성능 최적화가 이 단계에서 수행될 수 있습니다.  

이 경우에는 *Node.js* 기반 조치를 바로 실행할 수 있으므로 호출기는 Node.js 컨테이너를 시작합니다. 그리고 *myAction*에서 코드를 삽입하고 매개변수 없이 이를 실행하며 해당 결과를 추출하고 로그를 저장한 후에 Node.js 컨테이너를 다시 영구 삭제합니다. 

### 결과 저장: CouchDB (다시)

호출기가 결과를 받으면 이는 ActivationId 아래에서 활성화로서 **whisks** 데이터베이스에 저장됩니다. **whisks** 데이터베이스는 **CouchDB**에 상주합니다. 

이 특정한 경우에, 호출기는 조치에서 다시 결과 JSON 오브젝트를 가져오고, Docker에 의해 작성된 로그를 가져오며 이 모두를 활성화 레코드에 두고 이를 데이터베이스에 저장합니다. 다음 예제를 참조하십시오. 

```json
{
   "activationId": "31809ddca6f64cfc9de2937ebd44fbb9",
   "response": {
       "statusCode": 0,
       "result": {
           "hello": "world"
       }
   },
   "end": 1474459415621,
   "logs": [
       "2016-09-21T12:03:35.619234386Z stdout: Hello World"
   ],
   "start": 1474459415595,
}
```
{: codeblock}

리턴된 결과와 작성된 로그가 둘 다 레코드에 포함되는 방법에 유념하십시오. 여기에는 조치 호출의 시작 및 종료 시간도 포함됩니다. 활성화 레코드에는 추가 필드가 포함되지만, 단순화를 위해 이 예제에서는 이를 제거했습니다. 

이제는 다시 REST API를 사용하여(다시 1단계에서 시작함) 활성화 및 조치의 결과를 가져올 수 있습니다. 이를 수행하려면 다음 명령을 실행하십시오. 

```bash
wsk activation get 31809ddca6f64cfc9de2937ebd44fbb9
```
{: pre} 

### 요약

사용자는 단순한 **wsk action invoked myAction**이 {{site.data.keyword.openwhisk_short}} 시스템의 서로 다른 단계를 거치는 방법을 볼 수 있습니다. 시스템 자체는 기본적으로 2개의 사용자 정의 컴포넌트인 **제어기** 및 **호출기**로만 구성되어 있습니다. 기타 모든 컴포넌트는 오픈 소스 커뮤니티의 많은 개발자들에 의해 개발되어 이미 마련되어 있습니다. 

다음 주제에서 {{site.data.keyword.openwhisk_short}}에 대한 추가 정보를 찾을 수 있습니다.

* [엔티티 이름](./openwhisk_reference.html#openwhisk_entities)
* [조치 시맨틱](./openwhisk_reference.html#openwhisk_semantics)
* [한계](./openwhisk_reference.html#openwhisk_syslimits)
* [REST API](./openwhisk_reference.html#openwhisk_ref_restapi)

---

copyright:
  years: 2016, 2018
lastupdated: "2018-01-09"

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# Comparación de Función como servicio
{: #openwhisk_faas_compared}

La arquitectura sin servidor no resulta una panacea para todos los problemas de cálculo, pero sí que resuelve algunos. Existen [muchos casos de uso](./openwhisk_use_cases.html) en los que un diseño sin servidor puede resultar una buena elección. Se comparan las siguientes arquitecturas:
{: shortdesc}

1. **Función como servicio (FaaS)** - gestionado OpenWhisk. IBM es el único proveedor que ofrece [OpenWhisk en {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/openwhisk) gestionado.

2. **Infraestructura como servicio (IaaS)** con OpenWhisk Roll Your Own (RYO). Los usuarios finales pueden descargar OpenWhisk desde Apache Incubation Project e instalarlo y ejecutarlo en [{{site.data.keyword.Bluemix_notm}} IaaS](https://console.ng.bluemix.net/catalog/?category=devices) o en otra [nube IaaS](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29).

3. **Plataforma como servicio (PaaS)** - tiempo de ejecución de aplicaciones gestionado. Un buen ejemplo es un tiempo de ejecución [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) que está gestionado por la implementación de CloudFoundry de {{site.data.keyword.Bluemix_notm}}.

4. **Contenedor como servicio (CaaS)** - entorno de contenedor gestionado. Un buen ejemplo es [Containers on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/?category=containerImages) de IBM.

5. **Infraestructura como servicio (IaaS)** con tiempo de ejecución Java EE. Un buen ejemplo es [WebSphere Application Server VM on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/services/websphere-application-server) de IBM.

A continuación se proporciona un resumen de los pros y los contras de cada arquitectura desde la **perspectiva de un usuario final** que desarrolla y utiliza aplicaciones en estos tiempos de ejecución:


| Tema | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	Unidad de aplicación	|	Una sola función (generalmente un pequeño bloque de código en JavaScript, Swift o contenedor Docker) - puede tener menos de un Kb, pero puede ser mayor. Generalmente no más de unos cuantos Kb.	|	Igual que columna (1)	|	Depende del tiempo de ejecución utilizado. Un archivo EAR o WAR, o un paquete de aplicación específico de otro lenguaje, generalmente de tamaño relativamente grande - Kb o incluso Mb con muchos servicios en un paquete, pero puede ser tan pequeño como un solo servicio.	|	Contenedor Docker es la unidad de despliegue.	|	VM con App Server con archivo EAR o WAR y otras dependencias - generalmente en unidades de Gb.	|
|	Tamaño de recurso	|	El usuario final no paga ni se preocupa de la memoria, CPU u otros recursos. Aunque la acción tenga un cierto tamaño, el usuario no se tiene que preocupar de eso	|	Alto. El usuario final debe suministrar un entorno IaaS y después instalar y configurar OpenWhisk sobre el mismo	|	Pequeño. El usuario final paga por la memoria y CPU necesarias para ejecutar las apps, pero no paga por las apps que no se ejecutan	|	Pequeño a mediano	|	Alto. El usuario final tiene que pagar por almacenamiento de disco, memoria, CPU y posiblemente otros componentes cuando la app se ejecuta. Cuando está detenida, solo se incurren en costes de almacenamiento	|
|	Instalación y configuración	|	No es necesario	|	Alto - todo lo hace el usuario final	|	No es necesario	|	Moderado - herramientas de gestión de hardware, red, SO y contenedor proporcionadas por el proveedor de CaaSs, imágenes, conectividad e instancias por el usuario final	|	Alto - instalación de hardware, red, SO y Java EE inicial proporcionada por el proveedor, configuración adicional, clúster y escalado por el usuario final	|
|	Tiempo de suministro	|	Milisegundos	|	Vea las columnas (4) y (5)	|	Minutos	|	Minutos	|	Horas	|
|	Administración continua	|	Ninguna	|	Alta	|	Ninguna	|	Moderada	|	Alta	|
|	Escalado elástico	|	Cada acción se escala de forma instantánea y de modo inherente en función de la carga. No es necesario suministrar las VM ni otros recursos por adelantado	|	No se proporciona - el usuario final debe proporcionar capacidad de cálculo en IaaS y gestionar el escalado de las VM. Una vez escaladas las VM, OpenWhisk escala las acciones automáticamente, pero los recursos se deben suministrar por adelantado	|	Automático, pero escalado lento. Durante una mayor carga, las acciones de escala pueden tardar varios minutos en completarse. El escalado automático requiere un ajuste cuidadoso	|	Automático, pero escalado lento. Durante una mayor carga, las acciones de escala pueden tardar varios minutos en completarse. El escalado automático requiere un ajuste cuidadoso	|	No se proporciona	|
|	Planificación de la capacidad	|	No es necesaria. FaaS proporciona automáticamente la capacidad necesaria	|	Es necesario suministrar suficiente capacidad de antemano o en un script	|	Se necesita cierta planificación de la capacidad, pero se proporciona cierto aumento automático de la capacidad	|	Se necesita cierta planificación de la capacidad, pero se proporciona cierto aumento automático de la capacidad	|	Se necesita suministrar suficiente capacidad de forma estática para gestionar puntas de carga de trabajo	|
|	Conexiones permanentes y estado	|	Limitado - no se puede mantener una conexión permanente, excepto en casos de almacenamiento de contenedor en memoria caché. Generalmente el estado se debe mantener en un recurso externo	|	Igual que columna (1)	|	Soportado - se puede mantener una conexión o socket abierto durante mucho tiempo, se puede guardar el estado en memoria entre llamadas	|	Soportado - se puede mantener una conexión o socket abierto durante mucho tiempo, se puede guardar el estado en memoria entre llamadas	|	Soportado - se puede mantener una conexión o socket abierto durante mucho tiempo, se puede guardar el estado en memoria entre llamadas	|
|	Mantenimiento	|	Ninguno, IBM gestiona toda la pila.	|	Significativo - depende del entorno de destino, el usuario debe suministrar hardware, red, SO, almacenamiento, BD, instalación y mantenimiento de OpenWhisk, etc.	|	Ninguno, el proveedor gestiona toda la pila.	|	Significativo - el usuario debe crear y mantener imágenes personalizadas, desplegar y gestionar contenedores, conexiones entre contenedores, etc.	|	Significativo - el usuario debe asignar las VM, gestionar y escalar servidores Java EE individualmente.	|
|	Alta disponibilidad (HA) y Recuperación tras desastre (DR)	|	Inherente / sin costes adicionales	|	Roll Your Own (RYO) 	|	Disponible con cargo adicional	|	Los contenedores anómalos se pueden reiniciar automáticamente	|	Disponible con cargo adicional, semiautomático. Las VM se pueden migrar tras error automáticamente	|
|	Seguridad	|	Proporcionada por el proveedor	|	Roll Your Own (RYO)	|	Combinación de RYO y proporcionado por el proveedor	|	Combinación de RYO y proporcionado por el proveedor	|	Roll Your Own (RYO)	|
|	Velocidad de desarrollador	|	Máxima	|	Máxima	|	Máxima	|	Promedia	|	Lenta	|
|	Utilización de recursos (recursos desocupados por los que aún se tiene que pagar)	|	Los recursos nunca están desocupados, ya que solo se invocan a petición. Cuando falta la carga de trabajo, no se produce ninguna asignación de recursos ni coste.	|	Como esta opción utiliza IaaS o CaaS, se aplican consideraciones similares a las de las columnas (4) y (5)	|	Algunos recursos pueden estar desocupados, y el escalado automático ayuda a eliminar los recursos desocupados. Siempre tiene que haber un determinado número de instancias en ejecución y es probable que se utilicen a menos del 50 % de su capacidad. Las instancias detenidas no cuestan nada	|	Parecido a la columna (3)	|	Algunos recursos pueden estar desocupados, pero no se da soporte al escalado automático. Siempre tiene que haber un determinado número de instancias en ejecución y es probable que se utilicen a menos del 50 % de su capacidad. Las instancias detenidas pueden incurrir en el coste de almacenamiento	|
|	Madurez	|	Madurez temprana	|	Madurez temprana	|	Madurez temprana	|	Madurez moderada	|	Madurez elevada	|
|	Límites de recursos	|	[Existen ciertos límites](./openwhisk_reference.html#openwhisk_syslimits)	|	Depende de los recursos asignados	|	No	|	No	|	No	|
|	Latencia para servicios que se utilizan poco	|	Es posible que las solicitudes poco frecuentes muestren un tiempo de respuesta de varios segundos, pero se mantiene en un rango de milisegundos para las siguientes solicitudes	|	Depende	|	Bajo	|	Bajo	|	Bajo - suponiendo que el sistema tenga suficientes recursos	|
|	Tipo de aplicación ideal	|	Proceso de sucesos, IoT, proceso de fondo móvil, microservicios. Definitivamente no apto para aplicaciones monolíticas. Consulte los [casos de uso](./openwhisk_use_cases.html)	|	Igual que la columna (1), pero cuando el usuario desea trabajar con una nube que no es de IBM o de forma local.	|	Aplicaciones web con una carga de trabajo de tipo 24x7, servicios que necesitan mantener la conexión abierta durante largos periodos de tiempo. Se puede utilizar para ejecutar microservicios o aplicaciones monolíticas	|	Ideal para aplicaciones de microservicios.	|	Aplicaciones empresariales tradicionales que se migran de local a la nube. Ideal para aplicaciones monolíticas	|
|	Granularidad de los cargos y facturación	|	[Por bloques de 100 milisegundos](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	Depende de la implementación - si se utiliza IaaS o CaaS, se aplican consideraciones similares - Consulte las columnas (4) y (5)	|	Normalmente se factura por hora (raramente por minuto) por el paquete de recursos (CPU + memoria + cierto espacio de disco)	|	Parecido a la columna (3)	|	Parecido a la columna (3)	|
|	Coste total de propiedad (TCO)	|	Para alcanzar el punto ideal, es probable que el coste de las aplicaciones sea una orden de magnitud menor que el de las alternativas. Puesto que los recursos se escalan automáticamente, nunca se produce un exceso de suministro.	|	Para despliegues en la nube, es probable que resulte más caro que OpenWhisk FaaS, pero un despliegue local puede resultar más económico que las arquitecturas tradicionales	|	Relativamente bajo - el usuario no tiene que suministrar ni gestionar recursos, y se puede centrar en el desarrollo de la aplicación. Cierto nivel de exceso de suministro en comparación con la opción sin servidor	|	Moderado - el usuario tiene que suministrar y gestionar los contenedores y la aplicación, y se podría producir un nivel de exceso de suministro en comparación con la opción sin servidor y PaaS	|	Relativamente alto - teniendo en cuenta que la migración de aplicaciones antiguas al modelo nativo de nube puede resultar muy caro, esta puede ser una opción más viable y económica para este tipo de apps.	|

---

copyright:
  years: 2016, 2018
lastupdated: "2018-01-09"

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# Function as a Service (FaaS) im Vergleich
{: #openwhisk_faas_compared}

Die serverunabhängige Architektur (Serverless Architecture) ist kein Heilmittel für alle Datenverarbeitungsprobleme, aber sie löst einige von ihnen. Es gibt zahlreiche [Anwendungsfälle](./openwhisk_use_cases.html), in denen das serverunabhängige Design eine gute Wahl darstellen kann. Die folgenden Architekturen werden verglichen:
{: shortdesc}

1. **Function as a Service (FaaS)** - verwaltetes OpenWhisk. IBM ist der einzige Anbieter für verwaltetes [OpenWhisk on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/openwhisk).

2. **Infrastructure as a Service (IaaS)** mit OpenWhisk Roll Your Own (RYO). Endbenutzer können OpenWhisk von Apache Incubation Project herunterladen und in [{{site.data.keyword.Bluemix_notm}} IaaS](https://console.ng.bluemix.net/catalog/?category=devices) oder einer anderen [IaaS-Cloud](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29) installieren und ausführen.

3. **Platform as a Service (PaaS)** - verwaltete Anwendungslaufzeit. Ein gutes Beispiel für diese Architektur ist die [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java)-Laufzeit, die von der {{site.data.keyword.Bluemix_notm}}-CloudFoundry-Implementierung verwaltet wird.

4. **Container as a Service (CaaS)** - verwaltete Containerumgebung. Ein gutes Beispiel ist [Containers on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/?category=containerImages) von IBM.

5. **Infrastructure as a Service (IaaS)** mit Java EE-Laufzeit. Ein gutes Beispiel ist [WebSphere Application Server VM on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/services/websphere-application-server) von IBM.

In der folgenden Übersicht werden die Vor- und Nachteile der einzelnen Architekturoptionen aus der **Perspektive eines Endbenutzers** zusammengefasst, der Anwendungen in diesen unterschiedlichen Laufzeiten entwickelt und betreibt:


| Thema | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	Anwendungseinheit	|	Einzelne Funktion (in der Regel ein kleiner Codeblock in einem JavaScript-, Swift- oder Docker-Container) - kann kleiner als ein KB oder auch größer sein. Meist nicht mehr als wenige KB.	|	Wie Spalte (1)	|	Hängt von der verwendeten Laufzeit ab. Eine EAR- oder WAR-Datei oder ein anderes sprachspezifisches Anwendungsbundle, meist relativ groß - KB oder sogar MB mit vielen Services in einem Bundle, oder aber auch nur so groß wie einzelner Service.	|	Docker-Container ist die Bereitstellungseinheit.	|	VM mit App-Server mit EAR- oder WAR-Datei und anderen Abhängigkeiten - Größe meist im GB-Bereich.	|
|	Ressourcenbedarf	|	Endbenutzer braucht Hauptspeicher, CPU-Kapazität oder andere Ressourcen nicht zu bezahlen und nicht dafür zu sorgen. Obwohl die Aktion einen Bedarf hat, muss sich der Benutzer nicht darum kümmern.	|	Hoch. Endbenutzer muss zuerst eine IaaS-Umgebung bereitstellen und anschließend OpenWhisk darin installieren und konfigurieren.	|	Gering. Endbenutzer bezahlen Speicher und CPU für die Ausführung von Apps, jedoch nichts für Apps, die nicht ausgeführt werden.	|	Gering bis mittel.	|	Hoch. Endbenutzer muss für Plattenspeicher, Hauptspeicher, CPUs und mögliche andere Komponenten zahlen, wenn die App ausgeführt wird. Wenn sie gestoppt ist, entstehen nur Speicherkosten.	|
|	Installation und Einrichtung	|	Keine erforderlich.	|	Aufwendig - erfolgt alles durch Endbenutzer.	|	Keine erforderlich.	|	Moderat - Hardware, Vernetzung, Betriebssystem, Tools für Container-Management durch CaaS-Anbieter bereitgestellt; Images, Konnektivität und Instanzen durch Endbenutzer.	|	Aufwendig - Hardware, Vernetzung, Betriebssystem, Java EE-Erstinstallation durch Anbieter; zusätzliche Konfiguration, Clustering, Skalierung durch Endbenutzer.	|
|	Bereitstellungszeit	|	Millisekunden	|	Siehe Spalten (4) und (5).	|	Minuten	|	Minuten	|	Stunden	|
|	Fortlaufende Verwaltung	|	Keine	|	Aufwendig	|	Keine	|	Moderat	|	Aufwendig	|
|	Elastisches Skalieren	|	Jede Aktion wird immer sofort und inhärent abhängig von der Last skaliert. Es ist nicht erforderlich, VMs oder andere Ressource im Voraus bereitzustellen.	|	Nicht bereitgestellt - Endbenutzer muss Rechnerkapazität auf IaaS-Plattform bereitstellen und die Skalierung von VMs verwalten. Wenn VMs skaliert wurden, skaliert OpenWhisk Aktionen automatisch, jedoch muss die Ressource im Voraus bereitgestellt werden.	|	Automatische, jedoch langsame Skalierung. In Phasen erhöhter Auslastung müssen Benutzer möglicherweise mehrere Minuten auf die Ausführung der Skalieraktion warten. Automatisches Skalieren erfordert sorgfältige Optimierung.	|	Automatische, jedoch langsame Skalierung. In Phasen erhöhter Auslastung müssen Benutzer möglicherweise mehrere Minuten auf die Ausführung der Skalieraktion warten. Automatisches Skalieren erfordert sorgfältige Optimierung.	|	Nicht bereitgestellt.	|
|	Kapazitätsplanung	|	Nicht erforderlich. FaaS stellt automatisch die erforderliche Kapazität bereit.	|	Bereitstellung ausreichender Kapazität im Voraus erforderlich oder durch ein Script.	|	Einige Kapazitätsplanung erforderlich, aber eine automatische Funktion zur Kapazitätserhöhung wird bereitgestellt.	|	Einige Kapazitätsplanung erforderlich, aber eine automatische Funktion zur Kapazitätserhöhung wird bereitgestellt.	|	Statische Bereitstellung ausreichender Kapazität zum Auffangen von Spitzenlasten erforderlich.	|
|	Persistente Verbindungen und Status	|	Begrenzt - kann keine persistente Verbindung außer beim Container-Caching aufrechterhalten. Allgemein muss der Status in einer externen Ressource verwaltet werden.	|	Wie Spalte (1)	|	Wird unterstützt - kann ein offenes Socket oder eine Verbindung über lange Zeit behalten, kann den Status zwischen Aufrufen im Arbeitsspeicher speichern.	|	Wird unterstützt - kann ein offenes Socket oder eine Verbindung über lange Zeit behalten, kann den Status zwischen Aufrufen im Arbeitsspeicher speichern.	|	Wird unterstützt - kann ein offenes Socket oder eine Verbindung über lange Zeit behalten, kann den Status zwischen Aufrufen im Arbeitsspeicher speichern.	|
|	Wartung	|	Keine - gesamter Stack wird von IBM verwaltet. |	Erheblich - abhängig von der Zielumgebung muss der Benutzer für Hardware, Vernetzung, Betriebssysteme, Speicher, Datenbankressourcen, Installation und Wartung von OpenWhisk usw. sorgen.	|	Keine - gesamter Stack wird vom Anbieter verwaltet. |	Erheblich - Benutzer muss angepasste Images erstellen und verwalten, Container bereitstellen und verwalten, Verbindungen zwischen Containern verwalten usw.	|	Erheblich - Benutzer muss VMs zuordnen, Java EE-Server einzeln verwalten und skalieren.	|
|	High Availability (HA - Hochverfügbarkeit) und Disaster Recovery (DR)	|	Inhärent / keine Zusatzkosten	|	Roll Your Own (RYO) 	|	Gegen Zusatzgebühr verfügbar	|	Ausgefallene Container können automatisch erneut gestartet werden.	|	Gegen Zusatzgebühr verfügbar, halbautomatisch. VMs können automatisch von anderen Ressourcen übernommen werden (Failover).	|
|	Sicherheit	|	Vom Anbieter bereitgestellt	|	Roll Your Own (RYO)	|	Mischung aus RYO und Anbieterleistung	|	Mischung aus RYO und Anbieterleistung	|	Roll Your Own (RYO)	|
|	Geschwindigkeit für Entwickler	|	Am höchsten	|	Am höchsten	|	Am höchsten	|	Durchschnittlich	|	Langsam	|
|	Auslastung von Ressourcen (inaktive Ressourcen, für die gezahlt werden muss)	|	Ressourcen sind nie inaktiv, da sie nur auf Anforderung aufgerufen werden. Wenn keine Auslastung vorhanden ist, treten keine Kosten oder Ressourcenzuordnungen auf. |	Da diese Option mit IaaS oder CaaS arbeitet, gilt Ähnliches wie in den Spalten (4) und (5).	|	Einige Ressourcen können inaktiv sein und automatisches Skalieren hilft beim Vermeiden inaktiver Ressourcen. Eine Reihe aktiver Instanzen muss immer vorhanden sein und wird wahrscheinlich zu weniger als 50% ihrer Kapazität ausgelastet. Gestoppte Instanzen kosten nichts.	|	Ähnlich wie Spalte (3)	|	Einige Ressourcen können inaktiv sein, jedoch wird automatisches Skalieren nicht unterstützt. Eine Reihe aktiver Instanzen muss immer vorhanden sein und wird wahrscheinlich zu weniger als 50% ihrer Kapazität ausgelastet. Für gestoppte Instanzen können Kosten für Speicher anfallen.	|
|	Reife	|	Früher Reifegrad.	|	Früher Reifegrad.	|	Früher Reifegrad.	|	Mittlerer Reifegrad.	|	Hoch ausgereift. |
|	Ressourcengrenzen	|	[Einige Begrenzungen gelten.](./openwhisk_reference.html#openwhisk_syslimits)	|	Abhängig von zugeordneten Ressourcen.	|	Nein	|	Nein	|	Nein	|
|	Latenz für selten genutzte Services	|	Seltene Anforderungen können zu Anfang mit einigen Sekunden Antwortzeit verbunden sein, was sich jedoch im Millisekundenbereich für nachfolgende Anforderungen bewegt.	|	Jeweils abhängig.	|	Niedrig.	|	Niedrig.	|	Niedrig - sofern das System über ausreichend Ressourcen verfügt	|
|	Optimaler Anwendungstyp	|	Ereignisverarbeitung, Internet der Dinge, Mobile-Back-End, Microservices. Definitiv nicht für monolithische Anwendungen. Siehe [Anwendungsfälle](./openwhisk_use_cases.html).	|	Wie in Spalte (1), jedoch wenn der Benutzer in einer anderen Cloud als IBM Cloud oder lokal (On-Premises) arbeiten möchte.	|	Webanwendungen mit 24x7-Auslastung, statusabhängige Services, die die Verbindung über lange Zeiträume offen halten müssen. Geeignet zur Ausführung von Microservices oder monolithischen Anwendungen.	|	Ideal geeignet für Microservice-Anwendungen.	|	Traditionelle Unternehmensanwendungen, die aus lokalen Umgebungen in die Cloud migriert wurden. Ideal geeignet für monolithische Anwendungen.	|
|	Gebührenaufteilung und Abrechnung	|	[Pro Block von 100 Millisekunden](https://console.ng.bluemix.net/openwhisk/learn/pricing).	|	Abhängig von der Implementierung - Wenn IaaS oder CaaS verwendet werden, gilt Ähnliches - siehe Spalten (4) und (5).	|	In der Regel Gebühr auf Stundenbasis (selten pro Minute) für ein Ressourcenpaket (CPU + Arbeitsspeicher + Plattenspeicher).	|	Ähnlich wie Spalte (3)	|	Ähnlich wie Spalte (3)	|
|	Anschaffungs- und Betriebskosten (TCO)	|	Bei Verwendung für optimal geeignete Anwendungen liegt die Größenordnung der Gebühren sehr wahrscheinlich unter der der Alternativen. Da Ressourcen automatisch skaliert werden, erfolgt keine Überbereitstellung. |	Für Cloudbereitstellungen ist es wahrscheinlich teurer als OpenWhisk FaaS, jedoch kann eine lokale Bereitstellung (On-Premises) jedoch günstiger als traditionelle Architekturen sein.	|	Relativ gering - Der Benutzer muss keine Ressourcen bereitstellen oder verwalten und kann sich auf seine Anwendungsentwicklung konzentrieren. Im Vergleich zu Serverless ist eine gewisse Überbereitstellung möglich.	|	Moderat - Der Benutzer muss Container und Anwendung bereitstellen und verwalten und es ist im Vergleich zu Serverless oder PaaS eine gewisse Überbereitstellung möglich.	|	Relativ hoch - In Anbetracht der möglicherweise sehr hohen Kosten für die Migration der traditionellen Anwendungen auf ein natives Cloudmodell kann dies ein durchaus gangbarer und ökonomischer Weg für die betreffenden Apps sein.	|

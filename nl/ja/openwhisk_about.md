---

copyright:
  years: 2016, 2018
lastupdated: "2018-01-09"

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# {{site.data.keyword.openwhisk_short}} の概要

{{site.data.keyword.openwhisk}} は、サーバーレス・コンピューティングまたは Function as a Service (FaaS) とも呼ばれるイベント・ドリブンの・コンピュート・プラットフォームであり、イベントまたは直接起動に応えてコードを実行します。次の図は、{{site.data.keyword.openwhisk}} アーキテクチャーの概要を示したものです。
{: shortdesc}

![{{site.data.keyword.openwhisk_short}} アーキテクチャー](./images/OpenWhisk.png)

イベントの例には、データベース・レコードへの変更、IoT センサーによる一定の気温を超えたことの感知、GitHub リポジトリーへの新規コードのコミット、Web アプリまたはモバイル・アプリからの単純な HTTP 要求などがあります。外部および内部イベント・ソースからのイベントは、トリガーを介して送信され、ルールによってアクションがそうしたイベントに反応できます。

アクションは、JavaScript または Swift の小さなコード断片であるか、Docker コンテナーに組み込まれたカスタム・バイナリー・コードであることが可能です。{{site.data.keyword.openwhisk_short}} のアクションは、トリガーが起動するたびに、瞬時にデプロイされて実行されます。起動するトリガーが多いほど、呼び出されるアクションが多くなります。トリガーが起動しなければ、アクション・コードは実行されないため、コストはゼロのままです。

アクションをトリガーに関連付けるほかに、{{site.data.keyword.openwhisk_short}} API、CLI、または iOS SDK を使用してアクションを直接呼び出すことが可能です。コードを作成することなく、一連のアクションをチェーニングすることもできます。チェーン内の各アクションは順に起動され、あるアクションの出力は次のアクションへの入力として順に渡されていきます。

従来型の長時間稼働する仮想マシンまたはコンテナーを使用する場合、複数の VM またはコンテナーをデプロイして、1 つのインスタンスで障害が起こっても回復できるようにすることが一般的です。しかし、{{site.data.keyword.openwhisk_short}} は、回復力に関連するコストのオーバーヘッドがない代替モデルを提供します。アクションをオンデマンドで実行するため、実行されるアクションの数がトリガー・レートに常に一致するので、本質的に拡張容易性を備え、使用率が最適化されます。さらに、開発者はコードにのみ集中できるようになり、基盤のサーバー、ストレージ、ネットワーク、およびオペレーティング・システム・インフラストラクチャーのモニター、パッチ、保護について気にする必要はありません。

サービスおよびイベント・プロバイダーとの統合をパッケージで追加することができます。パッケージは、フィードおよびアクションのバンドルです。フィードは、トリガー・イベントを起動するように外部イベント・ソースを構成するコードです。例えば、Cloudant 変更フィードで作成されるトリガーは、Cloudant データベースで文書が変更されるか追加されるたびにそのトリガーを起動するようにサービスを構成します。パッケージ内のアクションは、再使用可能なロジックを表します。サービス・プロバイダーがアクションを利用可能にすることによって、開発者はそのサービスをイベント・ソースとして使用し、そのサービスの API を呼び出すことができます。

既存のパッケージ・カタログを利用すると、素早く簡単に、有用な機能でアプリケーションを強化したり、エコシステム内の外部サービスにアクセスしたりできます。{{site.data.keyword.openwhisk_short}} 対応の外部サービスの例として、Cloudant、The Weather Company、Slack、GitHub などがあります。


## {{site.data.keyword.openwhisk_short}} の動作
{: #openwhisk_how}

OpenWhisk は、オープン・ソースのプロジェクトであり、Nginx、Kafka、Consul、Docker、CouchDB などがベースになっています。これらすべてのコンポーネントが一緒になって 「サーバーレスのイベント・ベースのプログラミング・サービス」を形成しています。すべのコンポーネントをもっと詳細に説明するために、システム内でのアクションの呼び出しを順に見ていきます。OpenWhisk における呼び出しはサーバーレス・エンジンが行うことの核心部であり、ユーザーがシステムに送り込んだコードを実行し、その実行の結果を返します。

### アクションの作成

説明にコンテキストを与えるために、まず、システムでアクションを作成できます。その後、そのアクションを使用して、システム内を順に見ていきながら概念について説明します。以下に示すコマンドでは、[OpenWhisk CLI の適切なセットアップ](https://github.com/openwhisk/openwhisk/tree/master/docs#setting-up-the-openwhisk-cli)が行われていると想定しています。

最初に、以下のコードを含んでいるファイル *action.js* を作成します。これは、「Hello World」を STDOUT に出力し、キー「hello」で「world」を含んでいる JSON オブジェクトを返すコードです。
```javascript
function main() {
    console.log('Hello World');
    return { hello: 'world' };
}
```
{: codeblock}

以下のコマンドを実行して、アクションを作成します。
```
wsk action create myAction action.js
```
{: pre}

次に、以下のコマンドを実行して、そのアクションを呼び出します。
```
wsk action invoke myAction --result
```
{: pre}

## 内部的な処理の流れ
OpenWhisk ではそれぞれの場面の背後で何が起こっているのでしょうか?

![OpenWhisk の処理の流れ](images/OpenWhisk_flow_of_processing.png)

### システムに入る: nginx

まず、ユーザーに面している OpenWhisk の API は、完全に HTTP ベースであり、RESTful 設計に従っています。したがって、wsk-CLI を介して送信されるコマンドは、実質的には OpenWhisk システムに対する HTTP 要求です。特定のコマンドは、おおよそ次のように変換されます。
```
POST /api/v1/namespaces/$userNamespace/actions/myAction
Host: $openwhiskEndpoint
```
{: screen}

ここで *$userNamespace* 変数に注意してください。1 人のユーザーは少なくとも 1 つの名前空間にアクセスできます。単純化するため、*myAction* が入れられた名前空間をユーザーが所有していると想定します。

システムへの最初のエントリー・ポイントは、HTTP およびリバース・プロキシー・サーバーである **nginx** を通るものです。これは、SSL 終端処理のためと、適切な HTTP 呼び出しを次のコンポーネントに転送するために使用されます。

### システムに入る: Controller

nginx は、HTTP 要求を **Controller** (OpenWhisk を介したパスの次のコンポーネント) に転送します。これは、実際の REST API (**Akka** および **Spray** に基づく) の Scala ベースの実装であるため、ユーザーが実行できるすべての処理のインターフェースの役割を果たします。これには、OpenWhisk のエンティティーに対する [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) 要求やアクションの呼び出しがあります。

Controller は、最初に、ユーザーが行おうとしていることのあいまいさを解消します。これは HTTP 要求内で使用される HTTP メソッドに基づいて行われます。上記の変換のとおりに、ユーザーが POST 要求を既存のアクションに発行して、Controller がこの要求を**アクションの呼び出し**に変換します。

Controller の中心的役割 (この名前の由来) を考えると、Controller は以下のすべてのステップにある程度関与します。

### 認証および許可: CouchDB

次に、Controller は、ユーザーが誰なのかを検証 (*認証*) し、そのエンティティーで実行しようとしていることを行う特権をユーザーが持っているかどうかを検証 (*許可*) します。要求に組み込まれている資格情報が、**CouchDB** インスタンス内のいわゆる**サブジェクト**・データベースに照らして検証されます。

ここでは、ユーザーが OpenWhisk のデータベース内に存在していること、およびアクション *myAction* (ユーザーが所有している名前空間内のアクションであると想定) を呼び出すための特権を備えていることが検査されます。ユーザーが名前空間を所有していることにより、実質上、ユーザーはアクションを呼び出すための特権を備えることになります。

すべてが正常に進んでいるため、次の処理ステージへのゲートが開きます。

### アクションを取得する: ここでも CouchDB

Controller は、ユーザーがアクションを呼び出すための許可と特権を持っていることを確認できたので、このアクション (この例では *myAction*) を CouchDB 内の **whisks** データベースからロードします。

アクションのレコードに主として含まれるのは、実行するコードと、アクションに渡すデフォルト・パラメーター (実際の呼び出し要求に組み込んだパラメーターとマージされる) です。また、実行時に課されるリソース制限 (例えば、消費が許可されるメモリー量) も含まれます。

この特定の例では、アクションはパラメーターを取りません (関数のパラメーター定義は空リストです)。したがって、アクションの特定のパラメーターも含め、デフォルト・パラメーターは設定されません。そのため、この観点から見て最も簡素な例になります。

### アクションの呼び出しに関与するもの: Consul

これで、Controller (より具体的に言えば、そのロード・バランシング部分) には、コードを実行するためのすべてのものが用意されています。ただし、それを行うために使用可能な主体を認識する必要があります。
サービス・ディスカバリー **Consul** を使用して、システムで使用可能な実行プログラムの正常性状況を継続的にチェックすることによって、そうした実行プログラムをモニターします。それらの実行プログラムを **Invoker** と呼びます。

Controller は、使用可能な Invoker を認識したため、その中の 1 つを、要求されたアクションの呼び出し用に選択します。

この例では、システムで使用可能な Invoker は 3 個あり (Invoker 0 から 2)、手元にあるアクションを起動するように *Invoker 2* を Controller が選択したと想定しましょう。

### 整列させる: Kafka

これ以降、送信した呼び出し要求に関して起こり得る望ましくない事態として、主に次の 2 つが考えられます。

1. システムがクラッシュして呼び出しが失われる可能性があります。
2. まず他の呼び出しが完了するのを待機しなければならないような重い負荷がシステムにかかる可能性があります。

両方に対する解答が、高スループットの分散パブリッシュ/サブスクライブ・メッセージング・システムである **Kafka** です。Controller と Invoker は、Kafka によってバッファーに入れられて永続化されるメッセージを介してのみ通信します。Kafka により、*OutOfMemoryException* のリスクがあるメモリー内でのバッファリングという負担から Controller と Invoker の両方が解放され、システムがクラッシュしてもメッセージが失われないことも確実になります。

次にアクションを呼び出すために、Controller はメッセージを Kafka にパブリッシュします。このメッセージには、呼び出すアクション、およびそのアクションに渡すパラメーター (この例ではゼロ個) が含まれます。このメッセージの宛先は、Controller が Consul から取得したリストから選択した Invoker です。

Kafka がメッセージを取得したことを確認すると、ユーザーへの HTTP 要求は **ActivationId** を伴って応答されます。ユーザーは後でそれを使用して、この特定の呼び出しの結果にアクセスできます。これは非同期呼び出しモデルであり、HTTP 要求はアクションを呼び出す要求をシステムが受け入れると終了します。同期モデル (ブロッキング呼び出しと呼ばれます) も使用可能ですが、ここでは説明しません。

### コードを呼び出す: Invoker

**Invoker** は OpenWhisk の中心です。Invoker の責務は、アクションを呼び出すことです。これも Scala で実装されます。しかし、これにはそれ以上のものがあります。隔離して安全にアクションを実行するために、**Docker** を使用します。

Docker の使用によって、隔離され制御された方法で素早くアクションが実行されるよう、呼び出すアクションごとに自己包含環境 (*コンテナー* と呼ばれます) が新しくセットアップされます。アクションの呼び出しごとに、Docker コンテナーが spawn され、アクション・コードが注入されます。その後、渡されたパラメーターを使用してコードが実行され、結果が取得され、コンテナーが破棄されます。この段階でパフォーマンスの最適化を行って、オーバーヘッドを削減し、短い応答時間を可能にすることができます。 

この例では、*Node.js* ベースのアクションが用意されており、Invoker が Node.js コンテナーを開始します。次に、*myAction* からコードを注入し、パラメーターなしで実行して、結果を抽出し、ログを保存してから、Node.js コンテナーを再度破棄します。

### 結果を保管する: ここでも CouchDB

結果が Invoker によって取得されると、結果は **whisks** データベースに、ActivationID の下でアクティベーションとして保管されます。**whisks** データベースは **CouchDB** 内にあります。

ここで使用している特定の例では、Invoker は結果の JSON オブジェクトをアクションから返され、Docker によって書き込まれたログを取得し、それらをすべてアクティベーション・レコードに入れ、そのレコードをデータベースに保管します。以下の例を参照してください。

```json
{
   "activationId": "31809ddca6f64cfc9de2937ebd44fbb9",
   "response": {
       "statusCode": 0,
       "result": {
           "hello": "world"
       }
   },
   "end": 1474459415621,
   "logs": [
       "2016-09-21T12:03:35.619234386Z stdout: Hello World"
   ],
   "start": 1474459415595,
}
```
{: codeblock}

返された結果と書き込まれたログの両方がどのようにレコードに含まれているのかに注意してください。また、アクションの呼び出しの開始時刻および終了時刻も含まれています。アクティベーション・レコードには、より多くのフィールドが含まれていますが、この例では分かりやすくするために単純化されています。

次に、REST API を再度使用して (再びステップ 1 から開始して)、アクティベーションを取得し、アクションの結果を取得できます。そのために、以下のコマンドを実行します。

```bash
wsk activation get 31809ddca6f64cfc9de2937ebd44fbb9
```
{: pre} 

### まとめ

単純な **wsk action invoked myAction** がどのように {{site.data.keyword.openwhisk_short}} システムのさまざまなステージを通過していくのかが分かりました。システム自体は、主に 2 つのみのカスタム・コンポーネント、**Controller** と **Invoker** からなります。他のすべては、オープン・ソース・コミュニティーの多くの人によって開発され、既に存在しています。

{{site.data.keyword.openwhisk_short}} に関する追加情報が以下のトピックに記載されています。

* [エンティティー名](./openwhisk_reference.html#openwhisk_entities)
* [アクションの意味](./openwhisk_reference.html#openwhisk_semantics)
* [制限](./openwhisk_reference.html#openwhisk_syslimits)
* [REST API](./openwhisk_reference.html#openwhisk_ref_restapi)

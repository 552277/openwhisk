---

copyright:
  years: 2016, 2018
lastupdated: "2018-01-09"

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# Function as a Service との比較
{: #openwhisk_faas_compared}

サーバーレス・アーキテクチャーはコンピューティングのすべての問題を解決するわけではありませんが、解決するものもあります。サーバーレス設計が適切な選択となる[多くのユース・ケース](./openwhisk_use_cases.html)があります。以下のアーキテクチャーの比較を示します。
{: shortdesc}

1. **Function as a Service (FaaS)** - 管理された OpenWhisk。IBM は、管理された [OpenWhisk を {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/openwhisk) 上で提供する唯一のベンダーです。

2. **Infrastructure as a Service (IaaS)** で OpenWhisk ユーザー作成プログラム (RYO) を使用。エンド・ユーザーは、Apache Incubation Project から OpenWhisk をダウンロードし、[{{site.data.keyword.Bluemix_notm}} IaaS](https://console.ng.bluemix.net/catalog/?category=devices)、またはその他の [IaaS クラウド](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29)にインストールして実行できます。

3. **Platform as a Service (PaaS)** - 管理されたアプリケーション・ランタイム。{{site.data.keyword.Bluemix_notm}} CloudFoundry 実装で管理された [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) ランタイムがその良い例です。

4. **Container as a Service (CaaS)** - 管理されたコンテナー環境。IBM の [Containers on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/?category=containerImages) がその良い例です。

5. **Infrastructure as a Service (IaaS)** で Java EE ランタイムを使用。IBM が提供する [{{site.data.keyword.Bluemix_notm}} 上の WebSphere Application Server VM](https://console.ng.bluemix.net/catalog/services/websphere-application-server) がその良い例です。

各種ランタイムでアプリケーションを開発して運用する**エンド・ユーザーの観点**から、各アーキテクチャーの長所と短所を以下に要約して示します。


| トピック | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	アプリケーション単位	|	単一関数 (通常、JavaScript、Swift、または Docker コンテナーの小さなコード・ブロック)。1 KB を下回る場合も上回る場合もあります。通常は数 KB 以下です。|	列 (1) と同じ	|	使用されるランタイムによって異なります。 EAR ファイルまたは WAR ファイル、またはその他の言語固有のアプリケーション・バンドル。通常、1 つのバンドル内に多数のサービスがあり比較的大きくなります (KB サイズ、さらには MB サイズの場合もあります)。一方で、サービスが 1 つの小さいものもあります。|	デプロイメントの単位は Docker コンテナーです。|	EAR ファイルまたは WAR ファイルとその他の依存関係を使用したアプリケーション・サーバーを含む VM。通常は GB のサイズです。|
|	リソースのフットプリント|	エンド・ユーザーは、メモリー、CPU、その他のリソースについて費用を支払うことも配慮することもありません。アクションにいくらかのフットプリントはありますが、ユーザーがそれを心配する必要はありません。|	大。 エンド・ユーザーは必ず IaaS 環境をまずプロビジョンしてから、その上に OpenWhisk をインストールして構成する必要があります。|	小。エンド・ユーザーはアプリを実行するためのメモリーと CPU について費用を支払いますが、実行中でないアプリについては費用は発生しません。|	小から中|	大。 エンド・ユーザーは、アプリ実行中には、ディスク・ストレージ、メモリー、CPU、および場合によってはその他のコンポーネントについても費用を支払う必要があります。アプリ停止時には、ストレージ・コストのみが発生します。|
|	インストールとセットアップ|	不要	|	困難。エンド・ユーザーがすべてを行います。|	不要	|	中程度。ハードウェア、ネットワーキング、OS、コンテナー管理ツールは CaaS ベンダーが、イメージ、接続、インスタンスはエンド・ユーザーが提供します。|	困難。ハードウェア、ネットワーキング、OS、初期 Java EE インストールはベンダーが、追加の構成、クラスタリング、スケーリングはエンド・ユーザーが提供します。|
|	プロビジョニングの時間	|	数ミリ秒	|	列 (4) と (5) を参照|	数分	|	数分	|	数時間	|
|	進行中の管理	|	なし	|	困難	|	なし	|	中程度	|	困難	|
|	弾力性に優れたスケーリング |	各アクションは常に負荷に応じて即時かつ本質的にスケーリングされます。VM および他のリソースを事前にプロビジョンする必要はありません。|	提供されません。エンド・ユーザーが、IaaS でコンピュート・キャパシティーを提供し、VM のスケーリングを管理する必要があります。VM がいったんスケーリングされると、OpenWhisk が自動的にアクションをスケーリングしますが、リソースは事前にプロビジョン済みでなければなりません。|	自動ですが、スケーリングには時間がかかります。負荷が増加している間、ユーザーがスケーリング・アクションの完了を数分間待つ可能性があります。自動スケーリングには、入念な調整が必要です。|	自動ですが、スケーリングには時間がかかります。負荷が増加している間、ユーザーがスケーリング・アクションの完了を数分間待つ可能性があります。自動スケーリングには、入念な調整が必要です。|	提供されません	|
|	キャパシティー・プランニング	|	不要。必要なキャパシティーを FaaS が自動的に提供します。|	事前に十分なキャパシティーをプロビジョンするか、スクリプト化する必要があります。|	ある程度のキャパシティー・プランニングが必要ですが、ある程度の自動のキャパシティー増強が提供されます。|	ある程度のキャパシティー・プランニングが必要ですが、ある程度の自動のキャパシティー増強が提供されます。|	ピーク時のワークロードを処理できるだけの十分なキャパシティーを静的にプロビジョンする必要があります。|
|	持続的な接続および状態 |	限定的。コンテナー・キャッシングの場合を除き、持続的な接続を保持できません。一般的に、状態は外部リソースで保持される必要があります。|	列 (1) と同じ	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出しと呼び出しの間はメモリーに状態を保管できます。|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出しと呼び出しの間はメモリーに状態を保管できます。|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出しと呼び出しの間はメモリーに状態を保管できます。|
|	保守	|	なし。スタック全体が IBM によって管理されます。	|	かなり大。ターゲット環境に応じて、ユーザーによるハードウェア、ネットワーキング、OS、ストレージ、DB のプロビジョン、OpenWhisk のインストールおよび保守などが必要です。|	なし。スタック全体がベンダーによって管理されます。	|	かなり大。ユーザーがカスタム・イメージの作成と保守、コンテナーのデプロイと管理、コンテナー間の接続の管理などを行う必要があります。|	かなり大。ユーザーが VM を割り振り、Java EE サーバーを個々に管理してスケーリングする必要があります。|
|	高可用性 (HA) と災害復旧 (DR)|	内在 / 追加コストはありません|	ユーザー作成プログラム (RYO)|	利用には追加料金が必要です。|	失敗したコンテナーを自動的に再始動することができます。|	半自動で、利用には追加料金が必要です。VM を自動的にフェイルオーバーすることができます。|
|	セキュリティー	|	ベンダーによって提供される	|	ユーザー作成プログラム (RYO)|	RYO とベンダー提供の混合|	RYO とベンダー提供の混合|	ユーザー作成プログラム (RYO)|
|	開発者の速度	|	最速	|	最速	|	最速	|	平均	|	低速	|
|	リソース使用状況 (アイドルであっても支払いが必要なリソース)|	リソースは、要求時にのみ起動されるので、アイドルになることはありません。ワークロードがない場合、コストは発生せず、リソース割り振りも発生しません。|	このオプションは IaaS または CaaS を使用するため、列 (4) および (5) と同様の考慮事項が適用されます。|	一部のリソースがアイドルになる可能性があり、アイドル状態のリソースをなくすのに自動スケーリングが役立ちます。多数の実行中インスタンスが常時存在する必要があり、これらの使用はキャパシティーの 50 % に満たないことが多くあります。停止済みのインスタンスにコストはかかりません。|	列 (3) と同様	|	一部のリソースがアイドルになる可能性がありますが、自動スケーリングはサポートされません。いくつかの実行中インスタンスが常時存在する必要があり、これらの使用はキャパシティーの 50 % に満たないことが多くあります。停止済みのインスタンスに、ストレージのコストが発生する場合があります。|
|	成熟度	|	早期の成熟度|	早期の成熟度|	早期の成熟度|	中程度の成熟度	|	高い成熟度	|
|	リソース制限	|	[いくつかの制限があります](./openwhisk_reference.html#openwhisk_syslimits)。	|	割り振られたリソースによって異なります。|	なし	|	なし	|	なし	|
|	使用頻度の低いサービスの待ち時間|	頻度の低い要求では、最初は何秒かの応答時間がかかることがありますが、その後の要求ではミリ秒の範囲にとどまります。|	場合によって異なる |	小	|	小	|	小。システムに十分なリソースがあることが前提|
|	最適なアプリケーション・タイプ|	イベント処理、IoT、モバイル・バックエンド、マイクロサービス。モノリシック・アプリケーションには明らかに不適です。[ユース・ケース](./openwhisk_use_cases.html)を参照	|	列 (1) と同じですが、ユーザーが 非 IBM クラウドで、またはオンプレミスで実行する必要がある場合です。|	24 時間 365 日の作業負荷がある Web アプリケーション、接続を長期間オープンにしておく必要があるステートフル・サービス。マイクロサービスまたはモノリシック・アプリケーションの実行に使用できます。|	マイクロサービス・アプリケーションに最適。|	オンプレミスからクラウドにマイグレーションされた従来型のエンタープライズ・アプリケーション。モノリシック・アプリケーションに最適。|
|	課金の細分度と請求処理|	[100 ミリ秒のブロックごと](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	実装によって異なる。IaaS または CaaS が使用されている場合、同様の考慮事項が適用されます。列 (4) および (5) を参照。|	通常は、一括にしたリソース (CPU + メモリー + 一定のディスク・スペース) に対して時間単位 (まれに、分単位) で課金されます。|	列 (3) と同様	|	列 (3) と同様	|
|	総所有コスト (TCO)	|	優位点として、アプリケーションのコストが他の選択肢よりも桁違いに低くなる可能性があります。リソースが自動的にスケーリングされるため、オーバープロビジョニングは発生しません。|	クラウド・デプロイメントでは、OpenWhisk FaaS よりコストが高くなる可能性が大きいですが、オンプレミス・デプロイメントでは、従来型のアーキテクチャーより安くなる可能性があります。|	比較的低い。ユーザーはリソースをプロビジョンしたり管理したりする必要がなく、アプリケーション開発に集中できます。サーバーレスに比べてある程度のオーバープロビジョニングがあります。|	中程度。ユーザーはコンテナーおよびアプリケーションをプロビジョンして管理する必要があり、サーバーレスまたは PaaS と比べて一定レベルのオーバープロビジョニングが発生することがあります。|	比較的高い。レガシー・アプリケーションをクラウド・ネイティブ・モデルへマイグレーションすることに非常にコストがかかる可能性があることを考えると、そうしたアプリ向けの実現可能で経済的な選択肢になり得ます。|

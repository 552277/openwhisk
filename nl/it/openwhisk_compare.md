---

copyright:
  years: 2016, 2018
lastupdated: "2018-01-09"

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# FaaS (Function as a Service) a confronto
{: #openwhisk_faas_compared}

L'architettura senza server non è una panacea per tutti i problemi di calcolo, ma ne risolve alcuni. Esistono [molti casi di utilizzo](./openwhisk_use_cases.html) in cui la progettazione senza server può essere una buona scelta. Vengono confrontate le seguenti architetture:
{: shortdesc}

1. **FaaS (Function as a Service)** - OpenWhisk gestito. IBM è l'unico fornitore ad offrire [OpenWhisk gestito su {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/openwhisk).

2. **IaaS (Infrastructure as a Service)** con RYO (Roll Your Own) OpenWhisk. Gli utenti finali possono scaricare OpenWhisk da Apache Incubation Project e installarlo ed eseguirlo in [IaaS {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/?category=devices) o in un altro [cloud IaaS](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29).

3. **PaaS (Platform as a Service)** - runtime dell'applicazione gestito. Un buon esempio è il runtime [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) che è gestito dall'implementazione di {{site.data.keyword.Bluemix_notm}} CloudFoundry.

4. **CaaS (Container as a Service)** - ambiente di contenitori gestito. Un buon esempio è [Containers on {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/?category=containerImages) di IBM.

5. **IaaS (Infrastructure as a Service)** con il runtime Java EE. Un buon esempio è [VM WebSphere Application Server su {{site.data.keyword.Bluemix_notm}}](https://console.ng.bluemix.net/catalog/services/websphere-application-server) da IBM.

Viene fornito un riepilogo di pro e contro per ogni architettura dalla **prospettiva di un utente finale** che sviluppa e utilizza le applicazioni su questi diversi runtime:


| Argomento | (1) FaaS OpenWhisk | (2) RYO OpenWhisk | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	Unità di applicazione |	Funzione singola (normalmente un piccolo blocco di codice in JavaScript, in Swift o nel contenitore Docker) - può essere inferiore a 1 Kb ma anche più grande. Di solito non più di pochi Kb.	|	Come la colonna (1)	|	Dipende dal runtime utilizzato. Un file EAR o WAR, o altro bundle di applicazioni specifico per il linguaggio, di solito relativamente grande - Kb o anche Mb con molti servizi in un bundle, ma può essere piccolo come un singolo servizio.	|	Il contenitore Docker è l'unità di distribuzione.	|	VM con server delle applicazioni con il file EAR o WAR e altre dipendenze - solitamente con dimensioni in Gb.	|
|	Footprint della risorsa	|	L'utente finale non paga o si preoccupa della memoria, della CPU o di altre risorse. Sebbene l'azione abbia qualche footprint, l'utente non se ne deve preoccupare	|	Alto. L'utente finale deve prima eseguire il provisioning dell'ambiente IaaS e solo successivamente installare e configurare OpenWhisk su di esso	|	Piccolo. L'utente finale paga per la memoria e la CPU delle applicazioni in esecuzione, ma non paga nulla per le applicazioni che non sono in esecuzione	|	Da piccolo a medio|	Alto. L'utente finale deve pagare per l'archiviazione su disco, la memoria, le CPU e, eventualmente, altri componenti quando l'applicazione è in esecuzione. Quando viene arrestata, vengono addebitati solo i costi di archiviazione	|
|	Installazione e configurazione|	Nessuna richiesta|	Difficile - tutto eseguito dall'utente finale	|	Nessuna richiesta|	Moderata - Hardware, rete, SO, strumenti di gestione contenitore forniti dal fornitore di CaaSs immagini, connettività e istanze dall'utente finale	|	Difficile - Hardware, rete, SO, installazione iniziale di Java EE forniti dal fornitore, ulteriore configurazione, clustering e scalabilità dall'utente finale	|
|	Tempo di provisioning	|	Millisecondi	|	Vedi le colonne (4) e (5)	|	Minuti	|	Minuti	|	Ore	|
|	Amministrazione in corso	|	Nessuno |	Difficile	|	Nessuno |	Moderato	|	Difficile	|
|	Ridimensionamento elastico	|	Ogni azione è sempre istantaneamente e intrinsecamente ridimensionata a seconda del carico. Non è necessario eseguire il provisioning di VM o di altre risorse in anticipo|	Non fornito - l'utente finale deve fornire la capacità di calcolo su IaaS e gestire il ridimensionamento delle VM. Una volta ridimensionate le VM, OpenWhisk ridimensiona automaticamente l'azione, ma il provisioning delle risorse deve già essere stato eseguito|	Ridimensionamento automatico ma lento. Durante l'aumento del carico, gli utenti potrebbero attendere il completamento dell'azione di ridimensionamento per diversi minuti. Il ridimensionamento automatico richiede un'attenta ottimizzazione	|	Ridimensionamento automatico ma lento. Durante l'aumento del carico, gli utenti potrebbero attendere il completamento dell'azione di ridimensionamento per diversi minuti. Il ridimensionamento automatico richiede un'attenta ottimizzazione		|	Non fornito|
|	Pianificazione della capacità	|	Non necessario. FaaS fornisce automaticamente la capacità necessaria	|	È necessario eseguire il provisioning di una capacità sufficiente in anticipo o eseguirne lo script	|	È necessaria qualche pianificazione della capacità, ma viene fornito un aumento automatico della capacità	|	È necessaria qualche pianificazione della capacità, ma viene fornito un aumento automatico della capacità	|	È necessario eseguire in modo statico il provisioning di una capacità sufficiente per gestire il carico di lavoro massimo |
|	Connessioni persistenti e stato |	Limitato - può mantenere una connessione persistente, tranne nei casi di memorizzazione del contenitore nella cache. Generalmente lo stato deve essere mantenuto in una risorsa esterna	|	Come la colonna (1)	|	Supportato: può mantenere un socket o una connessione aperta per lunghi periodi, può memorizzare lo stato in memoria tra le chiamate	|	Supportato: può mantenere un socket o una connessione aperta per lunghi periodi, può memorizzare lo stato in memoria tra le chiamate	|	Supportato: può mantenere un socket o una connessione aperta per lunghi periodi, può memorizzare lo stato in memoria tra le chiamate	|
|	Manutenzione |	Nessuna - L'intero stack è gestito da IBM.	|	Significativa - a seconda dell'ambiente di destinazione, l'utente deve eseguire il provisioning di hardware, rete, SO, archiviazione, DB, installare e gestire OpenWhisk e così via.	|	Nessuna - L'intero stack è gestito dal fornitore.	|	Significativa - L'utente deve creare e gestire immagini personalizzate, distribuire e gestire contenitori, connessioni tra contenitori e così via. |	Significativa - L'utente deve assegnare VM, gestire e ridimensionare i server Java EE singolarmente.	|
|	Elevata disponibilità (HA) e Ripristino di emergenza (DR)	|	Intrinseco / nessun costo aggiuntivo	|	RYO (Roll your own) 	|	Disponibile a un costo aggiuntivo |	I contenitori non riusciti possono essere riavviati automaticamente	|	Disponibile a un costo aggiuntivo, semiautomatico. È possibile impostare il failover automatico delle VM|
|	Sicurezza |	Fornita dal fornitore	|	RYO (Roll your own) 	|	Combinazione di RYO fornita dal fornitore|	Combinazione di RYO fornita dal fornitore|	RYO (Roll your own) 	|
|	Velocità sviluppatore	|	Massima |	Massima |	Massima |	Media |	Lenta |
|	Utilizzo delle risorse (risorse inattive che devono ancora essere pagate)	|	Le risorse non sono mai inattive poiché vengono richiamate solo su richiesta. Quando il carico di lavoro è assente, non si verifica alcun costo o assegnazione delle risorse.	|	Poiché questa opzione utilizza IaaS o CaaS, si applicano considerazioni simili come nelle colonne (4) e (5)	|	Alcune risorse possono essere inattive e il ridimensionamento automatico aiuta a eliminare tali risorse. Deve essere presente sempre un certo numero di istanze in esecuzione e possono essere utilizzate con meno del 50% della loro capacità. Le istanze arrestate non costano nulla	|	Simile alla colonna (3)	|	Alcune risorse possono essere inattive, ma il ridimensionamento automatico non è supportato. Deve essere presente sempre un certo numero di istanze in esecuzione e possono essere utilizzate con meno del 50% della loro capacità. Le istanza arrestate possono sostenere il costo di archiviazione	|
|	Maturità |	Maturità anticipata	|	Maturità anticipata	|	Maturità anticipata	|	Maturità moderata	|	Maturità elevata |
|	Limiti delle risorse	|	[Esistono alcuni limiti](./openwhisk_reference.html#openwhisk_syslimits)	|	Dipende dalle risorse assegnate	|	No	|	No	|	No	|
|	Latenza per i servizi utilizzati raramente	|	Le richieste rare possono vedere inizialmente un tempo di risposta di diversi secondi, ma rimangono nell'intervallo ms per le richieste successive	|	Dipende	|	Bassa	|	Bassa	|	Bassa - supponendo che il sistema abbia risorse sufficienti|
|	Tipo di punto ottimale dell'applicazione |	Elaborazione evento, IoT, backend mobile, microservizi. Sicuramente non per le applicazioni monolitiche. Vedi [Casi di utilizzo](./openwhisk_use_cases.html)	|	Come la colonna (1), ma quando l'utente vuole eseguire su un cloud non IBM o in loco.	|	Applicazioni web con carico di lavoro 24x7, servizi con stato che devono mantenere la connessione aperta per lunghi periodi di tempo. Può essere utilizzato per eseguire microservizi o applicazioni monolitiche	|	Ideale per le applicazioni di microservizi.|	Applicazioni aziendali tradizionali migrate dall'istallazione in loco al cloud. Ideale per le applicazioni monolitiche	|
|	Addebito della granularità e fatturazione |	[Per blocchi di 100 millisecondi](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	Dipende dall'implementazione - Se vengono utilizzati IaaS o CaaS, si applicano considerazioni simili - Vedi le colonne (4) e (5)	|	Solitamente addebito all'ora (raramente al minuto) per un bundle di risorse (CPU + memoria + spazio su disco)	|	Simile alla colonna (3)	|	Simile alla colonna (3)	|
|	Total Cost of Ownership (TCO)	|	Per il suo punto ottimale, è probabile che le applicazioni costino un ordine di grandezza inferiore alle alternative. Poiché le risorse vengono ridimensionate automaticamente, non si verifica l'over-provisioning.	|	Per le distribuzioni cloud, è probabile che sia più costoso di FaaS OpenWhisk, ma la distribuzione in loco può essere più economica rispetto alle architetture tradizionali	|	Relativamente basso - l'utente non ha bisogno di eseguire il provisioning o di gestire risorse e può concentrarsi sullo sviluppo di applicazioni. Qualche livello di over-provisioning rispetto all'architettura senza server |	Moderato - L'utente deve eseguire il provisioning e gestire i contenitori e l'applicazione e potrebbe vedere un certo livello di over-provisioning rispetto all'architettura senza server o PaaS	|	Relativamente alto - Considerando che la migrazione di applicazioni legacy nel modello nativo del cloud potrebbe essere proibitivamente costosa, questa può essere una scelta praticabile ed economica per tali applicazioni. |
